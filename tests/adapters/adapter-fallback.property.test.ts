/**
 * AI Adapter Fallback ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
 *
 * Property 15: AI Adapter Fallback
 * - ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒå¤±æ•—ã—ãŸå ´åˆã€ã‚·ã‚¹ãƒ†ãƒ ã¯è¨­å®šã•ã‚ŒãŸãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ã‚’
 *   ä½¿ç”¨ã—ã¦ã‹ã‚‰å¤±æ•—ã‚’å ±å‘Šã™ã‚‹ã“ã¨
 *
 * **Validates: Requirements 7.5**
 *
 * @module tests/adapters/adapter-fallback.property.test
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fc from 'fast-check';
import {
  BaseAdapter,
  ExtendedAdapter,
  GenerateOptions,
  ChatOptions,
  ChatWithToolsOptions,
  AdapterResponse,
  ToolCallResponse,
  ToolDefinition,
  ModelInfo,
  AdapterConnectionError,
  AdapterFallbackError,
} from '../../tools/adapters/base';
import {
  AdapterRegistry,
  FallbackAdapter,
  createAdapterFromConfig,
} from '../../tools/adapters/index';

// =============================================================================
// ãƒ†ã‚¹ãƒˆç”¨ãƒ¢ãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿
// =============================================================================

/**
 * æˆåŠŸã™ã‚‹ãƒ¢ãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿
 */
class SuccessAdapter implements ExtendedAdapter {
  readonly name: string;
  private callCount = 0;

  constructor(name: string = 'success-adapter') {
    this.name = name;
  }

  async generate(options: GenerateOptions): Promise<AdapterResponse> {
    this.callCount++;
    return {
      content: `Generated by ${this.name}: ${options.prompt}`,
      model: options.model,
      tokensUsed: 10,
      finishReason: 'stop',
    };
  }

  async chat(options: ChatOptions): Promise<AdapterResponse> {
    this.callCount++;
    const lastMessage = options.messages[options.messages.length - 1];
    return {
      content: `Chat response from ${this.name}: ${lastMessage.content}`,
      model: options.model,
      tokensUsed: 15,
      finishReason: 'stop',
    };
  }

  async chatWithTools(options: ChatWithToolsOptions): Promise<ToolCallResponse> {
    this.callCount++;
    return {
      content: `Tool response from ${this.name}`,
      model: options.model,
      tokensUsed: 20,
      finishReason: 'stop',
      toolCalls: [],
      isComplete: true,
    };
  }

  async isAvailable(): Promise<boolean> {
    return true;
  }

  async getModelInfo(): Promise<ModelInfo> {
    return {
      name: this.name,
      description: 'Test adapter',
      supportsTools: true,
      contextWindow: 4096,
    };
  }

  supportsTools(): boolean {
    return true;
  }

  getCallCount(): number {
    return this.callCount;
  }

  resetCallCount(): void {
    this.callCount = 0;
  }
}

/**
 * å¸¸ã«å¤±æ•—ã™ã‚‹ãƒ¢ãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿
 */
class FailingAdapter implements ExtendedAdapter {
  readonly name: string;
  private callCount = 0;

  constructor(name: string = 'failing-adapter') {
    this.name = name;
  }

  async generate(_options: GenerateOptions): Promise<AdapterResponse> {
    this.callCount++;
    throw new AdapterConnectionError(`${this.name} connection failed`);
  }

  async chat(_options: ChatOptions): Promise<AdapterResponse> {
    this.callCount++;
    throw new AdapterConnectionError(`${this.name} connection failed`);
  }

  async chatWithTools(_options: ChatWithToolsOptions): Promise<ToolCallResponse> {
    this.callCount++;
    throw new AdapterConnectionError(`${this.name} connection failed`);
  }

  async isAvailable(): Promise<boolean> {
    return false;
  }

  async getModelInfo(): Promise<ModelInfo> {
    return {
      name: this.name,
      description: 'Failing test adapter',
      supportsTools: true,
      contextWindow: 4096,
    };
  }

  supportsTools(): boolean {
    return true;
  }

  getCallCount(): number {
    return this.callCount;
  }

  resetCallCount(): void {
    this.callCount = 0;
  }
}

/**
 * Nå›å¤±æ•—ã—ã¦ã‹ã‚‰æˆåŠŸã™ã‚‹ãƒ¢ãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿
 */
class IntermittentAdapter implements ExtendedAdapter {
  readonly name: string;
  private callCount = 0;
  private failuresBeforeSuccess: number;

  constructor(name: string = 'intermittent-adapter', failuresBeforeSuccess: number = 2) {
    this.name = name;
    this.failuresBeforeSuccess = failuresBeforeSuccess;
  }

  async generate(options: GenerateOptions): Promise<AdapterResponse> {
    this.callCount++;
    if (this.callCount <= this.failuresBeforeSuccess) {
      throw new AdapterConnectionError(`${this.name} temporary failure (attempt ${this.callCount})`);
    }
    return {
      content: `Generated after ${this.callCount} attempts`,
      model: options.model,
      tokensUsed: 10,
      finishReason: 'stop',
    };
  }

  async chat(options: ChatOptions): Promise<AdapterResponse> {
    this.callCount++;
    if (this.callCount <= this.failuresBeforeSuccess) {
      throw new AdapterConnectionError(`${this.name} temporary failure (attempt ${this.callCount})`);
    }
    return {
      content: `Chat response after ${this.callCount} attempts`,
      model: options.model,
      tokensUsed: 15,
      finishReason: 'stop',
    };
  }

  async chatWithTools(options: ChatWithToolsOptions): Promise<ToolCallResponse> {
    this.callCount++;
    if (this.callCount <= this.failuresBeforeSuccess) {
      throw new AdapterConnectionError(`${this.name} temporary failure (attempt ${this.callCount})`);
    }
    return {
      content: `Tool response after ${this.callCount} attempts`,
      model: options.model,
      tokensUsed: 20,
      finishReason: 'stop',
      toolCalls: [],
      isComplete: true,
    };
  }

  async isAvailable(): Promise<boolean> {
    return this.callCount > this.failuresBeforeSuccess;
  }

  async getModelInfo(): Promise<ModelInfo> {
    return {
      name: this.name,
      description: 'Intermittent test adapter',
      supportsTools: true,
      contextWindow: 4096,
    };
  }

  supportsTools(): boolean {
    return true;
  }

  getCallCount(): number {
    return this.callCount;
  }

  resetCallCount(): void {
    this.callCount = 0;
  }
}

// =============================================================================
// ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ï¼ˆArbitraryï¼‰å®šç¾©
// =============================================================================

/**
 * æœ‰åŠ¹ãªãƒ¢ãƒ‡ãƒ«åã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const modelNameArb: fc.Arbitrary<string> = fc.constantFrom(
  'llama3',
  'llama3.1',
  'mistral',
  'codellama',
  'qwen2',
  'gpt-4',
  'claude-3'
);

/**
 * æœ‰åŠ¹ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const promptArb: fc.Arbitrary<string> = fc.string({ minLength: 1, maxLength: 500 });

/**
 * GenerateOptionsã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const generateOptionsArb: fc.Arbitrary<GenerateOptions> = fc.record({
  model: modelNameArb,
  prompt: promptArb,
  system: fc.option(fc.string({ minLength: 1, maxLength: 200 }), { nil: undefined }),
  temperature: fc.option(fc.double({ min: 0, max: 1 }), { nil: undefined }),
  maxTokens: fc.option(fc.integer({ min: 100, max: 4096 }), { nil: undefined }),
});

/**
 * ChatMessageã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const chatMessageArb = fc.record({
  role: fc.constantFrom('system', 'user', 'assistant') as fc.Arbitrary<'system' | 'user' | 'assistant'>,
  content: fc.string({ minLength: 1, maxLength: 300 }),
});

/**
 * ChatOptionsã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const chatOptionsArb: fc.Arbitrary<ChatOptions> = fc.record({
  model: modelNameArb,
  messages: fc.array(chatMessageArb, { minLength: 1, maxLength: 10 }),
  temperature: fc.option(fc.double({ min: 0, max: 1 }), { nil: undefined }),
  maxTokens: fc.option(fc.integer({ min: 100, max: 4096 }), { nil: undefined }),
});

/**
 * ToolDefinitionã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const toolDefinitionArb: fc.Arbitrary<ToolDefinition> = fc.record({
  name: fc.stringOf(fc.constantFrom(...'abcdefghijklmnopqrstuvwxyz_'.split('')), {
    minLength: 3,
    maxLength: 30,
  }),
  description: fc.string({ minLength: 10, maxLength: 200 }),
  parameters: fc.constant({
    type: 'object' as const,
    properties: {
      input: { type: 'string' as const, description: 'Input parameter' },
    },
    required: ['input'],
  }),
});

/**
 * ChatWithToolsOptionsã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const chatWithToolsOptionsArb: fc.Arbitrary<ChatWithToolsOptions> = fc.record({
  model: modelNameArb,
  messages: fc.array(chatMessageArb, { minLength: 1, maxLength: 5 }),
  tools: fc.array(toolDefinitionArb, { minLength: 1, maxLength: 3 }),
  temperature: fc.option(fc.double({ min: 0, max: 1 }), { nil: undefined }),
  maxTokens: fc.option(fc.integer({ min: 100, max: 4096 }), { nil: undefined }),
});

/**
 * ãƒªãƒˆãƒ©ã‚¤å›æ•°ã‚’ç”Ÿæˆã™ã‚‹Arbitrary
 */
const maxRetriesArb: fc.Arbitrary<number> = fc.integer({ min: 1, max: 5 });

/**
 * ãƒªãƒˆãƒ©ã‚¤é…å»¶ã‚’ç”Ÿæˆã™ã‚‹Arbitraryï¼ˆãƒ†ã‚¹ãƒˆç”¨ã«çŸ­ã„å€¤ï¼‰
 */
const retryDelayArb: fc.Arbitrary<number> = fc.integer({ min: 10, max: 100 });

// =============================================================================
// Property 15: AI Adapter Fallback ãƒ†ã‚¹ãƒˆ
// =============================================================================

describe('Property 15: AI Adapter Fallback', () => {
  let primaryAdapter: FailingAdapter;
  let fallbackAdapter: SuccessAdapter;
  let fallbackAdapterInstance: FallbackAdapter;

  beforeEach(() => {
    primaryAdapter = new FailingAdapter('primary');
    fallbackAdapter = new SuccessAdapter('fallback');
    fallbackAdapterInstance = new FallbackAdapter(primaryAdapter, fallbackAdapter, {
      maxRetries: 3,
      retryDelayMs: 10, // ãƒ†ã‚¹ãƒˆç”¨ã«çŸ­ã„é…å»¶
    });
  });

  afterEach(() => {
    primaryAdapter.resetCallCount();
    fallbackAdapter.resetCallCount();
  });

  /**
   * Property 15.1: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚Œã‚‹
   *
   * *For any* AI request where the primary adapter fails, the system SHALL
   * attempt to use the configured fallback adapter before reporting failure.
   *
   * **Validates: Requirements 7.5**
   */
  it('Property 15.1: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚Œã‚‹ï¼ˆgenerateï¼‰', async () => {
    await fc.assert(
      fc.asyncProperty(generateOptionsArb, async (options) => {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ã§ç”Ÿæˆã‚’å®Ÿè¡Œ
        const result = await fallbackAdapterInstance.generate(options);

        // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚ŒãŸã“ã¨
        expect(result.content).toContain('fallback');

        // æ¤œè¨¼: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒè©¦è¡Œã•ã‚ŒãŸã“ã¨ï¼ˆãƒªãƒˆãƒ©ã‚¤å›æ•°åˆ†ï¼‰
        expect(primaryAdapter.getCallCount()).toBe(3);

        // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã“ã¨
        expect(fallbackAdapter.getCallCount()).toBe(1);

        // ãƒªã‚»ãƒƒãƒˆ
        primaryAdapter.resetCallCount();
        fallbackAdapter.resetCallCount();
      }),
      { numRuns: 50 }
    );
  });

  /**
   * Property 15.2: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚Œã‚‹ï¼ˆchatï¼‰
   *
   * **Validates: Requirements 7.5**
   */
  it('Property 15.2: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚Œã‚‹ï¼ˆchatï¼‰', async () => {
    await fc.assert(
      fc.asyncProperty(chatOptionsArb, async (options) => {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ã§ãƒãƒ£ãƒƒãƒˆã‚’å®Ÿè¡Œ
        const result = await fallbackAdapterInstance.chat(options);

        // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚ŒãŸã“ã¨
        expect(result.content).toContain('fallback');

        // æ¤œè¨¼: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒè©¦è¡Œã•ã‚ŒãŸã“ã¨
        expect(primaryAdapter.getCallCount()).toBe(3);

        // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã“ã¨
        expect(fallbackAdapter.getCallCount()).toBe(1);

        // ãƒªã‚»ãƒƒãƒˆ
        primaryAdapter.resetCallCount();
        fallbackAdapter.resetCallCount();
      }),
      { numRuns: 50 }
    );
  });

  /**
   * Property 15.3: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚Œã‚‹ï¼ˆchatWithToolsï¼‰
   *
   * **Validates: Requirements 7.5**
   */
  it('Property 15.3: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚Œã‚‹ï¼ˆchatWithToolsï¼‰', async () => {
    await fc.assert(
      fc.asyncProperty(chatWithToolsOptionsArb, async (options) => {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ã§ãƒ„ãƒ¼ãƒ«ä»˜ããƒãƒ£ãƒƒãƒˆã‚’å®Ÿè¡Œ
        const result = await fallbackAdapterInstance.chatWithTools(options);

        // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚ŒãŸã“ã¨
        expect(result.content).toContain('fallback');

        // æ¤œè¨¼: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒè©¦è¡Œã•ã‚ŒãŸã“ã¨
        expect(primaryAdapter.getCallCount()).toBe(3);

        // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã“ã¨
        expect(fallbackAdapter.getCallCount()).toBe(1);

        // ãƒªã‚»ãƒƒãƒˆ
        primaryAdapter.resetCallCount();
        fallbackAdapter.resetCallCount();
      }),
      { numRuns: 50 }
    );
  });

  /**
   * Property 15.4: ãƒ—ãƒ©ã‚¤ãƒãƒªã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸¡æ–¹ãŒå¤±æ•—ã—ãŸå ´åˆã€AdapterFallbackErrorãŒæŠ•ã’ã‚‰ã‚Œã‚‹
   *
   * **Validates: Requirements 7.5**
   */
  it('Property 15.4: ãƒ—ãƒ©ã‚¤ãƒãƒªã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸¡æ–¹ãŒå¤±æ•—ã—ãŸå ´åˆã€AdapterFallbackErrorãŒæŠ•ã’ã‚‰ã‚Œã‚‹', async () => {
    const bothFailingAdapter = new FallbackAdapter(
      new FailingAdapter('primary'),
      new FailingAdapter('fallback'),
      { maxRetries: 2, retryDelayMs: 10 }
    );

    await fc.assert(
      fc.asyncProperty(generateOptionsArb, async (options) => {
        // ä¸¡æ–¹å¤±æ•—ã™ã‚‹å ´åˆã€AdapterFallbackErrorãŒæŠ•ã’ã‚‰ã‚Œã‚‹
        await expect(bothFailingAdapter.generate(options)).rejects.toThrow(AdapterFallbackError);
      }),
      { numRuns: 30 }
    );
  });

  /**
   * Property 15.5: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒæˆåŠŸã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ä½¿ç”¨ã•ã‚Œãªã„
   *
   * **Validates: Requirements 7.5**
   */
  it('Property 15.5: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒæˆåŠŸã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ä½¿ç”¨ã•ã‚Œãªã„', async () => {
    const successPrimary = new SuccessAdapter('primary');
    const successFallback = new SuccessAdapter('fallback');
    const adapter = new FallbackAdapter(successPrimary, successFallback, {
      maxRetries: 3,
      retryDelayMs: 10,
    });

    await fc.assert(
      fc.asyncProperty(generateOptionsArb, async (options) => {
        // ç”Ÿæˆã‚’å®Ÿè¡Œ
        const result = await adapter.generate(options);

        // æ¤œè¨¼: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒä½¿ç”¨ã•ã‚ŒãŸã“ã¨
        expect(result.content).toContain('primary');

        // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ€ãƒ—ã‚¿ã¯å‘¼ã³å‡ºã•ã‚Œã¦ã„ãªã„ã“ã¨
        expect(successFallback.getCallCount()).toBe(0);

        // ãƒªã‚»ãƒƒãƒˆ
        successPrimary.resetCallCount();
        successFallback.resetCallCount();
      }),
      { numRuns: 50 }
    );
  });

  /**
   * Property 15.6: ãƒªãƒˆãƒ©ã‚¤å›æ•°ãŒè¨­å®šé€šã‚Šã«å‹•ä½œã™ã‚‹
   *
   * **Validates: Requirements 7.5**
   */
  it('Property 15.6: ãƒªãƒˆãƒ©ã‚¤å›æ•°ãŒè¨­å®šé€šã‚Šã«å‹•ä½œã™ã‚‹', async () => {
    await fc.assert(
      fc.asyncProperty(maxRetriesArb, generateOptionsArb, async (maxRetries, options) => {
        const failingPrimary = new FailingAdapter('primary');
        const successFallback = new SuccessAdapter('fallback');
        const adapter = new FallbackAdapter(failingPrimary, successFallback, {
          maxRetries,
          retryDelayMs: 10,
        });

        // ç”Ÿæˆã‚’å®Ÿè¡Œ
        await adapter.generate(options);

        // æ¤œè¨¼: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒmaxRetrieså›è©¦è¡Œã•ã‚ŒãŸã“ã¨
        expect(failingPrimary.getCallCount()).toBe(maxRetries);
      }),
      { numRuns: 30 }
    );
  });

  /**
   * Property 15.7: é–“æ¬ çš„ãªå¤±æ•—ã‹ã‚‰ãƒªãƒˆãƒ©ã‚¤ã§å›å¾©ã§ãã‚‹
   *
   * **Validates: Requirements 7.5**
   */
  it('Property 15.7: é–“æ¬ çš„ãªå¤±æ•—ã‹ã‚‰ãƒªãƒˆãƒ©ã‚¤ã§å›å¾©ã§ãã‚‹', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.integer({ min: 1, max: 2 }), // 1-2å›å¤±æ•—ã—ã¦ã‹ã‚‰æˆåŠŸ
        generateOptionsArb,
        async (failuresBeforeSuccess, options) => {
          const intermittentPrimary = new IntermittentAdapter('primary', failuresBeforeSuccess);
          const successFallback = new SuccessAdapter('fallback');
          const adapter = new FallbackAdapter(intermittentPrimary, successFallback, {
            maxRetries: 3, // 3å›ãƒªãƒˆãƒ©ã‚¤ã™ã‚Œã°æˆåŠŸã™ã‚‹ã¯ãš
            retryDelayMs: 10,
          });

          // ç”Ÿæˆã‚’å®Ÿè¡Œ
          const result = await adapter.generate(options);

          // æ¤œè¨¼: ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ãƒ€ãƒ—ã‚¿ãŒæœ€çµ‚çš„ã«æˆåŠŸã—ãŸã“ã¨
          expect(result.content).toContain('attempts');

          // æ¤œè¨¼: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„ã“ã¨
          expect(successFallback.getCallCount()).toBe(0);
        }
      ),
      { numRuns: 30 }
    );
  });
});

// =============================================================================
// AdapterRegistry ãƒ†ã‚¹ãƒˆ
// =============================================================================

describe('AdapterRegistry', () => {
  let registry: AdapterRegistry;

  beforeEach(() => {
    registry = new AdapterRegistry();
  });

  afterEach(() => {
    registry.clearAdapters();
  });

  /**
   * ç™»éŒ²æ¸ˆã¿ã‚¢ãƒ€ãƒ—ã‚¿åã®ä¸€è¦§ãŒå–å¾—ã§ãã‚‹
   */
  it('ç™»éŒ²æ¸ˆã¿ã‚¢ãƒ€ãƒ—ã‚¿åã®ä¸€è¦§ãŒå–å¾—ã§ãã‚‹', () => {
    const names = registry.getRegisteredAdapterNames();
    expect(names).toContain('ollama');
  });

  /**
   * ã‚¢ãƒ€ãƒ—ã‚¿ã‚’åå‰ã§å–å¾—ã§ãã‚‹
   */
  it('ã‚¢ãƒ€ãƒ—ã‚¿ã‚’åå‰ã§å–å¾—ã§ãã‚‹', () => {
    const adapter = registry.getAdapter('ollama');
    expect(adapter).toBeDefined();
    expect(adapter.name).toBe('ollama');
  });

  /**
   * å­˜åœ¨ã—ãªã„ã‚¢ãƒ€ãƒ—ã‚¿ã‚’å–å¾—ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼
   */
  it('å­˜åœ¨ã—ãªã„ã‚¢ãƒ€ãƒ—ã‚¿ã‚’å–å¾—ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼', () => {
    expect(() => registry.getAdapter('nonexistent')).toThrow();
  });

  /**
   * ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒ€ãƒ—ã‚¿ã‚’ç™»éŒ²ã§ãã‚‹
   */
  it('ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒ€ãƒ—ã‚¿ã‚’ç™»éŒ²ã§ãã‚‹', () => {
    const customAdapter = new SuccessAdapter('custom');
    registry.registerAdapter('custom', customAdapter);

    const retrieved = registry.getAdapter('custom');
    expect(retrieved).toBe(customAdapter);
  });

  /**
   * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ€ãƒ—ã‚¿ã‚’è¨­å®šãƒ»å–å¾—ã§ãã‚‹
   */
  it('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ€ãƒ—ã‚¿ã‚’è¨­å®šãƒ»å–å¾—ã§ãã‚‹', () => {
    const defaultAdapter = registry.getDefaultAdapter();
    expect(defaultAdapter.name).toBe('ollama');
  });

  /**
   * ExtendedAdapterã‹ã©ã†ã‹ã‚’åˆ¤å®šã§ãã‚‹
   */
  it('ExtendedAdapterã‹ã©ã†ã‹ã‚’åˆ¤å®šã§ãã‚‹', () => {
    const adapter = registry.getAdapter('ollama');
    expect(registry.isExtendedAdapter(adapter)).toBe(true);
  });
});

// =============================================================================
// createAdapterFromConfig ãƒ†ã‚¹ãƒˆ
// =============================================================================

describe('createAdapterFromConfig', () => {
  let registry: AdapterRegistry;

  beforeEach(() => {
    registry = new AdapterRegistry();
    // ãƒ†ã‚¹ãƒˆç”¨ã‚¢ãƒ€ãƒ—ã‚¿ã‚’ç™»éŒ²
    registry.registerAdapter('test-primary', new SuccessAdapter('test-primary'));
    registry.registerAdapter('test-fallback', new SuccessAdapter('test-fallback'));
  });

  afterEach(() => {
    registry.clearAdapters();
  });

  /**
   * ãƒ—ãƒ©ã‚¤ãƒãƒªã®ã¿ã®è¨­å®šã§ã‚¢ãƒ€ãƒ—ã‚¿ã‚’ä½œæˆã§ãã‚‹
   */
  it('ãƒ—ãƒ©ã‚¤ãƒãƒªã®ã¿ã®è¨­å®šã§ã‚¢ãƒ€ãƒ—ã‚¿ã‚’ä½œæˆã§ãã‚‹', () => {
    const adapter = createAdapterFromConfig({ primary: 'test-primary' }, registry);
    expect(adapter.name).toBe('test-primary');
  });

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãã®è¨­å®šã§FallbackAdapterã‚’ä½œæˆã§ãã‚‹
   */
  it('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãã®è¨­å®šã§FallbackAdapterã‚’ä½œæˆã§ãã‚‹', () => {
    const adapter = createAdapterFromConfig(
      {
        primary: 'test-primary',
        fallback: {
          fallbackAdapter: 'test-fallback',
          maxRetries: 3,
          retryDelayMs: 1000,
        },
      },
      registry
    );

    expect(adapter.name).toBe('test-primary+test-fallback');
    expect(adapter).toBeInstanceOf(FallbackAdapter);
  });
});

// =============================================================================
// ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
// =============================================================================

describe('AI Adapter Fallback - Edge Cases', () => {
  /**
   * ç©ºã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã§ã‚‚chatãŒå‹•ä½œã™ã‚‹
   */
  it('ç©ºã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã§ã‚‚chatãŒå‹•ä½œã™ã‚‹', async () => {
    const adapter = new SuccessAdapter('test');
    const result = await adapter.chat({
      model: 'llama3',
      messages: [{ role: 'user', content: '' }],
    });
    expect(result.content).toBeDefined();
  });

  /**
   * ç©ºã®ãƒ„ãƒ¼ãƒ«é…åˆ—ã§ã‚‚chatWithToolsãŒå‹•ä½œã™ã‚‹
   */
  it('ç©ºã®ãƒ„ãƒ¼ãƒ«é…åˆ—ã§ã‚‚chatWithToolsãŒå‹•ä½œã™ã‚‹', async () => {
    const adapter = new SuccessAdapter('test');
    const result = await adapter.chatWithTools({
      model: 'llama3',
      messages: [{ role: 'user', content: 'test' }],
      tools: [],
    });
    expect(result.content).toBeDefined();
    expect(result.isComplete).toBe(true);
  });

  /**
   * æ—¥æœ¬èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ­£ã—ãå‡¦ç†ã•ã‚Œã‚‹
   */
  it('æ—¥æœ¬èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ­£ã—ãå‡¦ç†ã•ã‚Œã‚‹', async () => {
    const adapter = new SuccessAdapter('test');
    const result = await adapter.generate({
      model: 'llama3',
      prompt: 'ã“ã‚Œã¯æ—¥æœ¬èªã®ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã™ã€‚çµµæ–‡å­—ã‚‚å«ã‚€ğŸš€',
    });
    expect(result.content).toContain('ã“ã‚Œã¯æ—¥æœ¬èªã®ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã™');
  });

  /**
   * éå¸¸ã«é•·ã„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒå‡¦ç†ã•ã‚Œã‚‹
   */
  it('éå¸¸ã«é•·ã„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒå‡¦ç†ã•ã‚Œã‚‹', async () => {
    const adapter = new SuccessAdapter('test');
    const longPrompt = 'a'.repeat(10000);
    const result = await adapter.generate({
      model: 'llama3',
      prompt: longPrompt,
    });
    expect(result.content).toBeDefined();
  });

  /**
   * FallbackAdapterã®isAvailableãŒæ­£ã—ãå‹•ä½œã™ã‚‹
   */
  it('FallbackAdapterã®isAvailableãŒæ­£ã—ãå‹•ä½œã™ã‚‹', async () => {
    // ãƒ—ãƒ©ã‚¤ãƒãƒªãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
    const adapter1 = new FallbackAdapter(
      new SuccessAdapter('primary'),
      new SuccessAdapter('fallback'),
      { maxRetries: 1, retryDelayMs: 10 }
    );
    expect(await adapter1.isAvailable()).toBe(true);

    // ãƒ—ãƒ©ã‚¤ãƒãƒªãŒåˆ©ç”¨ä¸å¯ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
    const adapter2 = new FallbackAdapter(
      new FailingAdapter('primary'),
      new SuccessAdapter('fallback'),
      { maxRetries: 1, retryDelayMs: 10 }
    );
    expect(await adapter2.isAvailable()).toBe(true);

    // ä¸¡æ–¹åˆ©ç”¨ä¸å¯ã®å ´åˆ
    const adapter3 = new FallbackAdapter(
      new FailingAdapter('primary'),
      new FailingAdapter('fallback'),
      { maxRetries: 1, retryDelayMs: 10 }
    );
    expect(await adapter3.isAvailable()).toBe(false);
  });

  /**
   * FallbackAdapterã®supportsToolsãŒæ­£ã—ãå‹•ä½œã™ã‚‹
   */
  it('FallbackAdapterã®supportsToolsãŒæ­£ã—ãå‹•ä½œã™ã‚‹', async () => {
    const adapter = new FallbackAdapter(
      new SuccessAdapter('primary'),
      new SuccessAdapter('fallback'),
      { maxRetries: 1, retryDelayMs: 10 }
    );
    expect(adapter.supportsTools()).toBe(true);
  });

  /**
   * FallbackAdapterã®getModelInfoãŒæ­£ã—ãå‹•ä½œã™ã‚‹
   */
  it('FallbackAdapterã®getModelInfoãŒæ­£ã—ãå‹•ä½œã™ã‚‹', async () => {
    const adapter = new FallbackAdapter(
      new SuccessAdapter('primary'),
      new SuccessAdapter('fallback'),
      { maxRetries: 1, retryDelayMs: 10 }
    );
    const info = await adapter.getModelInfo();
    expect(info.name).toBe('primary');
    expect(info.supportsTools).toBe(true);
  });
});
